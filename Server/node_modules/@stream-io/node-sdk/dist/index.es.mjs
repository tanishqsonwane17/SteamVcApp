import jwt from 'jsonwebtoken';
import { v4 } from 'uuid';
import crypto from 'crypto';

const ChannelOwnCapability = {
    BAN_CHANNEL_MEMBERS: 'ban-channel-members',
    CAST_POLL_VOTE: 'cast-poll-vote',
    CONNECT_EVENTS: 'connect-events',
    CREATE_ATTACHMENT: 'create-attachment',
    DELETE_ANY_MESSAGE: 'delete-any-message',
    DELETE_CHANNEL: 'delete-channel',
    DELETE_OWN_MESSAGE: 'delete-own-message',
    FLAG_MESSAGE: 'flag-message',
    FREEZE_CHANNEL: 'freeze-channel',
    JOIN_CHANNEL: 'join-channel',
    LEAVE_CHANNEL: 'leave-channel',
    MUTE_CHANNEL: 'mute-channel',
    PIN_MESSAGE: 'pin-message',
    QUERY_POLL_VOTES: 'query-poll-votes',
    QUOTE_MESSAGE: 'quote-message',
    READ_EVENTS: 'read-events',
    SEARCH_MESSAGES: 'search-messages',
    SEND_CUSTOM_EVENTS: 'send-custom-events',
    SEND_LINKS: 'send-links',
    SEND_MESSAGE: 'send-message',
    SEND_POLL: 'send-poll',
    SEND_REACTION: 'send-reaction',
    SEND_REPLY: 'send-reply',
    SEND_RESTRICTED_VISIBILITY_MESSAGE: 'send-restricted-visibility-message',
    SEND_TYPING_EVENTS: 'send-typing-events',
    SET_CHANNEL_COOLDOWN: 'set-channel-cooldown',
    SKIP_SLOW_MODE: 'skip-slow-mode',
    SLOW_MODE: 'slow-mode',
    TYPING_EVENTS: 'typing-events',
    UPDATE_ANY_MESSAGE: 'update-any-message',
    UPDATE_CHANNEL: 'update-channel',
    UPDATE_CHANNEL_MEMBERS: 'update-channel-members',
    UPDATE_OWN_MESSAGE: 'update-own-message',
    UPDATE_THREAD: 'update-thread',
    UPLOAD_FILE: 'upload-file',
};
const OwnCapability = {
    BLOCK_USERS: 'block-users',
    CHANGE_MAX_DURATION: 'change-max-duration',
    CREATE_CALL: 'create-call',
    CREATE_REACTION: 'create-reaction',
    ENABLE_NOISE_CANCELLATION: 'enable-noise-cancellation',
    END_CALL: 'end-call',
    JOIN_BACKSTAGE: 'join-backstage',
    JOIN_CALL: 'join-call',
    JOIN_ENDED_CALL: 'join-ended-call',
    MUTE_USERS: 'mute-users',
    PIN_FOR_EVERYONE: 'pin-for-everyone',
    READ_CALL: 'read-call',
    REMOVE_CALL_MEMBER: 'remove-call-member',
    SCREENSHARE: 'screenshare',
    SEND_AUDIO: 'send-audio',
    SEND_VIDEO: 'send-video',
    START_BROADCAST_CALL: 'start-broadcast-call',
    START_CLOSED_CAPTIONS_CALL: 'start-closed-captions-call',
    START_FRAME_RECORD_CALL: 'start-frame-record-call',
    START_RECORD_CALL: 'start-record-call',
    START_TRANSCRIPTION_CALL: 'start-transcription-call',
    STOP_BROADCAST_CALL: 'stop-broadcast-call',
    STOP_CLOSED_CAPTIONS_CALL: 'stop-closed-captions-call',
    STOP_FRAME_RECORD_CALL: 'stop-frame-record-call',
    STOP_RECORD_CALL: 'stop-record-call',
    STOP_TRANSCRIPTION_CALL: 'stop-transcription-call',
    UPDATE_CALL: 'update-call',
    UPDATE_CALL_MEMBER: 'update-call-member',
    UPDATE_CALL_PERMISSIONS: 'update-call-permissions',
    UPDATE_CALL_SETTINGS: 'update-call-settings',
};

function JWTUserToken(apiSecret, payload) {
    // make sure we return a clear error when jwt is shimmed (ie. browser build)
    if (jwt == null || jwt.sign == null) {
        throw Error(`Unable to find jwt crypto, if you are getting this error is probably because you are trying to generate tokens on browser or React Native (or other environment where crypto functions are not available). Please Note: token should only be generated server-side.`);
    }
    const opts = Object.assign({
        algorithm: 'HS256',
        noTimestamp: true,
    });
    if (payload.iat) {
        opts.noTimestamp = false;
    }
    return jwt.sign(payload, apiSecret, opts);
}
function JWTServerToken(apiSecret, jwtOptions = {}) {
    const payload = {
        server: true,
    };
    const opts = Object.assign({ algorithm: 'HS256', noTimestamp: true }, jwtOptions);
    return jwt.sign(payload, apiSecret, opts);
}

class StreamError extends Error {
    constructor(message, metadata, code, errorOptions) {
        super(message, errorOptions);
        this.metadata = metadata;
        this.code = code;
    }
}

const getRateLimitFromResponseHeader = (responseHeaders) => {
    const rateLimit = responseHeaders.has('x-ratelimit-limit')
        ? +responseHeaders.get('x-ratelimit-limit')
        : undefined;
    const rateLimitRemaining = responseHeaders.has('x-ratelimit-remaining')
        ? +responseHeaders.get('x-ratelimit-remaining')
        : undefined;
    const rateLimitReset = responseHeaders.has('x-ratelimit-reset')
        ? new Date(+responseHeaders.get('x-ratelimit-reset') * 1000)
        : undefined;
    const result = {
        rateLimit,
        rateLimitRemaining,
        rateLimitReset,
    };
    return result;
};

class BaseApi {
    constructor(apiConfig) {
        this.apiConfig = apiConfig;
        this.sendRequest = async (method, url, pathParams, queryParams, body) => {
            queryParams = queryParams ?? {};
            queryParams.api_key = this.apiConfig.apiKey;
            const encodedParams = this.queryParamsStringify(queryParams);
            if (pathParams) {
                Object.keys(pathParams).forEach((paramName) => {
                    url = url.replace(`{${paramName}}`, pathParams[paramName]);
                });
            }
            url += `?${encodedParams}`;
            const clientRequestId = v4();
            const headers = {
                Authorization: this.apiConfig.token,
                'stream-auth-type': 'jwt',
                'Content-Type': 'application/json',
                'X-Stream-Client': 'stream-node-' + "0.4.24",
                'Accept-Encoding': 'gzip',
                'x-client-request-id': clientRequestId,
            };
            const signal = AbortSignal.timeout(this.apiConfig.timeout);
            try {
                const response = await fetch(`${this.apiConfig.baseUrl}${url}`, {
                    signal,
                    method,
                    body: JSON.stringify(body),
                    headers,
                    dispatcher: this.dispatcher,
                });
                const responseHeaders = response.headers;
                const metadata = {
                    clientRequestId,
                    responseHeaders,
                    responseCode: response.status,
                    rateLimit: getRateLimitFromResponseHeader(responseHeaders),
                };
                if (response.status < 200 || response.status >= 300) {
                    let error;
                    try {
                        error = (await response.json());
                    }
                    catch (_) {
                        throw new StreamError(`Stream error: ${response.status} - ${response.statusText}`, metadata, response.status);
                    }
                    throw new StreamError(`Stream error code ${error.code}: ${error.message}`, metadata, error.code, undefined);
                }
                const responseBody = (await response.json());
                return { body: responseBody, metadata };
            }
            catch (error) {
                if (error instanceof StreamError) {
                    throw error;
                }
                const metadata = {
                    clientRequestId,
                    responseCode: error.status,
                };
                if (error.name === 'AbortError' || error.name === 'TimeoutError') {
                    throw new StreamError(`The request was aborted due to to the ${this.apiConfig.timeout}ms timeout, you can set the timeout in the StreamClient constructor`, metadata, undefined, error);
                }
                else {
                    throw new StreamError(`The request failed due to an unexpected error`, metadata, error);
                }
            }
        };
        this.queryParamsStringify = (params) => {
            const newParams = [];
            for (const k in params) {
                const param = params[k];
                if (Array.isArray(param)) {
                    newParams.push(`${k}=${encodeURIComponent(param.join(','))}`);
                }
                else if (param instanceof Date) {
                    newParams.push(param.toISOString());
                }
                else if (typeof param === 'object') {
                    newParams.push(`${k}=${encodeURIComponent(JSON.stringify(param))}`);
                }
                else {
                    if (typeof param === 'string' ||
                        typeof param === 'number' ||
                        typeof param === 'boolean') {
                        newParams.push(`${k}=${encodeURIComponent(param)}`);
                    }
                }
            }
            return newParams.join('&');
        };
        this.dispatcher = this.apiConfig.agent;
    }
}

const decoders = {};
const decodeDatetimeType = (input) => new Date(Math.floor(input / 1000000));
decoders.DatetimeType = decodeDatetimeType;
const decode = (typeMappings, input) => {
    if (!input || Object.keys(typeMappings).length === 0)
        return input;
    Object.keys(typeMappings).forEach((key) => {
        if (input[key] != null) {
            if (typeMappings[key]) {
                const decoder = decoders[typeMappings[key].type];
                if (decoder) {
                    if (typeMappings[key].isSingle) {
                        input[key] = decoder(input[key]);
                    }
                    else {
                        Object.keys(input[key]).forEach((k) => {
                            input[key][k] = decoder(input[key][k]);
                        });
                    }
                }
            }
        }
    });
    return input;
};
decoders.ActionLog = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItem', isSingle: true },
        target_user: { type: 'User', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ActionLogResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        review_queue_item: { type: 'ReviewQueueItem', isSingle: true },
        target_user: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AppResponseFields = (input) => {
    const typeMappings = {
        call_types: { type: 'CallType', isSingle: false },
        channel_configs: { type: 'ChannelConfig', isSingle: false },
        push_notifications: { type: 'PushNotificationFields', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.AutomodDetails = (input) => {
    const typeMappings = {
        result: { type: 'MessageModerationResult', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Ban = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'Channel', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        target: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BanResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        banned_by: { type: 'UserResponse', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockListResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockUsersResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.BlockedUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        blocked_user: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallParticipantResponse = (input) => {
    const typeMappings = {
        joined_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallRecording = (input) => {
    const typeMappings = {
        end_time: { type: 'DatetimeType', isSingle: true },
        start_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallReportResponse = (input) => {
    const typeMappings = {
        ended_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        ended_at: { type: 'DatetimeType', isSingle: true },
        starts_at: { type: 'DatetimeType', isSingle: true },
        session: { type: 'CallSessionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallSessionResponse = (input) => {
    const typeMappings = {
        participants: { type: 'CallParticipantResponse', isSingle: false },
        accepted_by: { type: 'DatetimeType', isSingle: false },
        missed_by: { type: 'DatetimeType', isSingle: false },
        rejected_by: { type: 'DatetimeType', isSingle: false },
        ended_at: { type: 'DatetimeType', isSingle: true },
        live_ended_at: { type: 'DatetimeType', isSingle: true },
        live_started_at: { type: 'DatetimeType', isSingle: true },
        started_at: { type: 'DatetimeType', isSingle: true },
        timer_ends_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStateResponseFields = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallStatsReportSummaryResponse = (input) => {
    const typeMappings = {
        first_stats_time: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTranscription = (input) => {
    const typeMappings = {
        end_time: { type: 'DatetimeType', isSingle: true },
        start_time: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallType = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        segments: { type: 'Segment', isSingle: false },
        users: { type: 'UserResponse', isSingle: false },
        stats: { type: 'CampaignStatsResponse', isSingle: true },
        scheduled_for: { type: 'DatetimeType', isSingle: true },
        stop_at: { type: 'DatetimeType', isSingle: true },
        sender: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CampaignStatsResponse = (input) => {
    const typeMappings = {
        stats_completed_at: { type: 'DatetimeType', isSingle: true },
        stats_started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Channel = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        invites: { type: 'ChannelMember', isSingle: false },
        members: { type: 'ChannelMember', isSingle: false },
        config: { type: 'ChannelConfig', isSingle: true },
        created_by: { type: 'User', isSingle: true },
        truncated_by: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelConfig = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelConfigWithInfo = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMember = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        archived_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        invite_accepted_at: { type: 'DatetimeType', isSingle: true },
        invite_rejected_at: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMemberResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        archived_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        invite_accepted_at: { type: 'DatetimeType', isSingle: true },
        invite_rejected_at: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelMute = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelPushPreferences = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        mute_expires_at: { type: 'DatetimeType', isSingle: true },
        truncated_at: { type: 'DatetimeType', isSingle: true },
        members: { type: 'ChannelMember', isSingle: false },
        config: { type: 'ChannelConfigWithInfo', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        truncated_by: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelStateResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMember', isSingle: false },
        messages: { type: 'MessageResponse', isSingle: false },
        pinned_messages: { type: 'MessageResponse', isSingle: false },
        threads: { type: 'ThreadStateResponse', isSingle: false },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        pending_messages: { type: 'PendingMessageResponse', isSingle: false },
        read: { type: 'ReadStateResponse', isSingle: false },
        watchers: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        membership: { type: 'ChannelMember', isSingle: true },
        push_preferences: { type: 'ChannelPushPreferences', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelStateResponseFields = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMember', isSingle: false },
        messages: { type: 'MessageResponse', isSingle: false },
        pinned_messages: { type: 'MessageResponse', isSingle: false },
        threads: { type: 'ThreadStateResponse', isSingle: false },
        hide_messages_before: { type: 'DatetimeType', isSingle: true },
        pending_messages: { type: 'PendingMessageResponse', isSingle: false },
        read: { type: 'ReadStateResponse', isSingle: false },
        watchers: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        membership: { type: 'ChannelMember', isSingle: true },
        push_preferences: { type: 'ChannelPushPreferences', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ChannelTypeConfig = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ChatActivityStatsResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageStatsResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CheckResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItem', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Command = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ConfigResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CountByMinuteResponse = (input) => {
    const typeMappings = {
        start_ts: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateCommandResponse = (input) => {
    const typeMappings = {
        command: { type: 'Command', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateGuestResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateImportResponse = (input) => {
    const typeMappings = {
        import_task: { type: 'ImportTask', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CreateRoleResponse = (input) => {
    const typeMappings = {
        role: { type: 'Role', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.CustomCheckResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeactivateUserResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteCallResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteChannelResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeleteReactionResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Device = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DeviceResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.DraftPayloadResponse = (input) => {
    const typeMappings = {
        mentioned_users: { type: 'UserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.DraftResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        message: { type: 'DraftPayloadResponse', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EgressRTMPResponse = (input) => {
    const typeMappings = {
        started_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EntityCreator = (input) => {
    const typeMappings = {
        ban_expires: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        last_engaged_at: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.EntityCreatorResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        devices: { type: 'DeviceResponse', isSingle: false },
        push_notifications: {
            type: 'PushNotificationSettingsResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.EventResponse = (input) => {
    const typeMappings = {
        event: { type: 'WSEvent', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ExportUserResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
        reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Flag = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FlagDetails = (input) => {
    const typeMappings = {
        automod: { type: 'AutomodDetails', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FlagFeedback = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.FullUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'DeviceResponse', isSingle: false },
        mutes: { type: 'UserMuteResponse', isSingle: false },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetApplicationResponse = (input) => {
    const typeMappings = {
        app: { type: 'AppResponseFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetBlockedUsersResponse = (input) => {
    const typeMappings = {
        blocks: { type: 'BlockedUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetCallReportResponse = (input) => {
    const typeMappings = {
        chat_activity: { type: 'ChatActivityStatsResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetCommandResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetConfigResponse = (input) => {
    const typeMappings = {
        config: { type: 'ConfigResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetDraftResponse = (input) => {
    const typeMappings = {
        draft: { type: 'DraftResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetImportResponse = (input) => {
    const typeMappings = {
        import_task: { type: 'ImportTask', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetManyMessagesResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageWithChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetOrCreateCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'Reaction', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetRepliesResponse = (input) => {
    const typeMappings = {
        messages: { type: 'MessageResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.GetReviewQueueItemResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItemResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetSegmentResponse = (input) => {
    const typeMappings = {
        segment: { type: 'SegmentResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetTaskResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GetThreadResponse = (input) => {
    const typeMappings = {
        thread: { type: 'ThreadStateResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.GoLiveResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ImportTask = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        history: { type: 'ImportTaskHistory', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ImportTaskHistory = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ListBlockListResponse = (input) => {
    const typeMappings = {
        blocklists: { type: 'BlockListResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListCallTypeResponse = (input) => {
    const typeMappings = {
        call_types: { type: 'CallTypeResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListChannelTypesResponse = (input) => {
    const typeMappings = {
        channel_types: { type: 'ChannelTypeConfig', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListCommandsResponse = (input) => {
    const typeMappings = {
        commands: { type: 'Command', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListDevicesResponse = (input) => {
    const typeMappings = {
        devices: { type: 'DeviceResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListImportsResponse = (input) => {
    const typeMappings = {
        import_tasks: { type: 'ImportTask', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListPushProvidersResponse = (input) => {
    const typeMappings = {
        push_providers: { type: 'PushProviderResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListRecordingsResponse = (input) => {
    const typeMappings = {
        recordings: { type: 'CallRecording', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListRolesResponse = (input) => {
    const typeMappings = {
        roles: { type: 'Role', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.ListTranscriptionsResponse = (input) => {
    const typeMappings = {
        transcriptions: { type: 'CallTranscription', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MarkReadResponse = (input) => {
    const typeMappings = {
        event: { type: 'MessageReadEvent', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MemberResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMember', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.Message = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'Reaction', isSingle: false },
        mentioned_users: { type: 'User', isSingle: false },
        own_reactions: { type: 'Reaction', isSingle: false },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'User', isSingle: false },
        pinned_by: { type: 'User', isSingle: true },
        poll: { type: 'Poll', isSingle: true },
        quoted_message: { type: 'Message', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageFlagResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        approved_at: { type: 'DatetimeType', isSingle: true },
        rejected_at: { type: 'DatetimeType', isSingle: true },
        reviewed_at: { type: 'DatetimeType', isSingle: true },
        details: { type: 'FlagDetails', isSingle: true },
        message: { type: 'Message', isSingle: true },
        moderation_feedback: { type: 'FlagFeedback', isSingle: true },
        moderation_result: { type: 'MessageModerationResult', isSingle: true },
        reviewed_by: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageHistoryEntryResponse = (input) => {
    const typeMappings = {
        message_updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageModerationResult = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageReadEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel_last_message_at: { type: 'DatetimeType', isSingle: true },
        thread: { type: 'ThreadResponse', isSingle: true },
        user: { type: 'UserResponseCommonFields', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MessageResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        draft: { type: 'DraftResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MessageStatsResponse = (input) => {
    const typeMappings = {
        count_over_time: { type: 'CountByMinuteResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MessageWithChannelResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        draft: { type: 'DraftResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.MuteChannelResponse = (input) => {
    const typeMappings = {
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        channel_mute: { type: 'ChannelMute', isSingle: true },
        own_user: { type: 'OwnUser', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.MuteResponse = (input) => {
    const typeMappings = {
        mutes: { type: 'UserMute', isSingle: false },
        own_user: { type: 'OwnUser', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.OwnUser = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'Device', isSingle: false },
        mutes: { type: 'UserMute', isSingle: false },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        last_engaged_at: { type: 'DatetimeType', isSingle: true },
        push_preferences: { type: 'PushPreferences', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.OwnUserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        channel_mutes: { type: 'ChannelMute', isSingle: false },
        devices: { type: 'DeviceResponse', isSingle: false },
        mutes: { type: 'UserMuteResponse', isSingle: false },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        push_preferences: { type: 'PushPreferences', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ParticipantCountByMinuteResponse = (input) => {
    const typeMappings = {
        start_ts: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ParticipantCountOverTimeResponse = (input) => {
    const typeMappings = {
        by_minute: { type: 'ParticipantCountByMinuteResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PendingMessageResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Poll = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_answers: { type: 'PollVote', isSingle: false },
        own_votes: { type: 'PollVote', isSingle: false },
        created_by: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollResponse = (input) => {
    const typeMappings = {
        poll: { type: 'PollResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_answers: { type: 'PollVoteResponseData', isSingle: false },
        own_votes: { type: 'PollVoteResponseData', isSingle: false },
        created_by: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVote = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVoteResponse = (input) => {
    const typeMappings = {
        vote: { type: 'PollVoteResponseData', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVoteResponseData = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PollVotesResponse = (input) => {
    const typeMappings = {
        votes: { type: 'PollVoteResponseData', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PushNotificationFields = (input) => {
    const typeMappings = {
        providers: { type: 'PushProvider', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.PushNotificationSettingsResponse = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushPreferences = (input) => {
    const typeMappings = {
        disabled_until: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushProvider = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        disabled_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.PushProviderResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        disabled_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryBannedUsersResponse = (input) => {
    const typeMappings = {
        bans: { type: 'BanResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallMembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallParticipantsResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        participants: { type: 'CallParticipantResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallStatsResponse = (input) => {
    const typeMappings = {
        reports: { type: 'CallStatsReportSummaryResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCallsResponse = (input) => {
    const typeMappings = {
        calls: { type: 'CallStateResponseFields', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryCampaignsResponse = (input) => {
    const typeMappings = {
        campaigns: { type: 'CampaignResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryChannelsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'ChannelStateResponseFields', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryDraftsResponse = (input) => {
    const typeMappings = {
        drafts: { type: 'DraftResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedModerationTemplate = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.QueryFeedModerationTemplatesResponse = (input) => {
    const typeMappings = {
        templates: { type: 'QueryFeedModerationTemplate', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryMessageFlagsResponse = (input) => {
    const typeMappings = {
        flags: { type: 'MessageFlagResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryMessageHistoryResponse = (input) => {
    const typeMappings = {
        message_history: { type: 'MessageHistoryEntryResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationConfigsResponse = (input) => {
    const typeMappings = {
        configs: { type: 'ConfigResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryModerationLogsResponse = (input) => {
    const typeMappings = {
        logs: { type: 'ActionLogResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryPollsResponse = (input) => {
    const typeMappings = {
        polls: { type: 'PollResponseData', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryReactionsResponse = (input) => {
    const typeMappings = {
        reactions: { type: 'ReactionResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryReviewQueueResponse = (input) => {
    const typeMappings = {
        items: { type: 'ReviewQueueItemResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QuerySegmentTargetsResponse = (input) => {
    const typeMappings = {
        targets: { type: 'SegmentTargetResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QuerySegmentsResponse = (input) => {
    const typeMappings = {
        segments: { type: 'SegmentResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryThreadsResponse = (input) => {
    const typeMappings = {
        threads: { type: 'ThreadStateResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.QueryUsersResponse = (input) => {
    const typeMappings = {
        users: { type: 'FullUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.Reaction = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionGroupResponse = (input) => {
    const typeMappings = {
        first_reaction_at: { type: 'DatetimeType', isSingle: true },
        last_reaction_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactionResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReactivateUserResponse = (input) => {
    const typeMappings = {
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReadStateResponse = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReviewQueueItem = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        actions: { type: 'ActionLog', isSingle: false },
        bans: { type: 'Ban', isSingle: false },
        flags: { type: 'Flag', isSingle: false },
        assigned_to: { type: 'User', isSingle: true },
        entity_creator: { type: 'EntityCreator', isSingle: true },
        feeds_v2_reaction: { type: 'Reaction', isSingle: true },
        message: { type: 'Message', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ReviewQueueItemResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        actions: { type: 'ActionLogResponse', isSingle: false },
        bans: { type: 'Ban', isSingle: false },
        completed_at: { type: 'DatetimeType', isSingle: true },
        reviewed_at: { type: 'DatetimeType', isSingle: true },
        assigned_to: { type: 'UserResponse', isSingle: true },
        entity_creator: { type: 'EntityCreatorResponse', isSingle: true },
        feeds_v2_reaction: { type: 'Reaction', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'Reaction', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.Role = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SearchResult = (input) => {
    const typeMappings = {
        message: { type: 'SearchResultMessage', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SearchResultMessage = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_reactions: { type: 'ReactionResponse', isSingle: false },
        mentioned_users: { type: 'UserResponse', isSingle: false },
        own_reactions: { type: 'ReactionResponse', isSingle: false },
        user: { type: 'UserResponse', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        message_text_updated_at: { type: 'DatetimeType', isSingle: true },
        pin_expires: { type: 'DatetimeType', isSingle: true },
        pinned_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'UserResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        pinned_by: { type: 'UserResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        quoted_message: { type: 'MessageResponse', isSingle: true },
        reaction_groups: { type: 'ReactionGroupResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.Segment = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SegmentResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SegmentTargetResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SendMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SendReactionResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.StopLiveResponse = (input) => {
    const typeMappings = {
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.SubmitActionResponse = (input) => {
    const typeMappings = {
        item: { type: 'ReviewQueueItem', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadParticipant = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        last_read_at: { type: 'DatetimeType', isSingle: true },
        last_thread_message_at: { type: 'DatetimeType', isSingle: true },
        left_thread_at: { type: 'DatetimeType', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        thread_participants: { type: 'ThreadParticipant', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.ThreadStateResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        latest_replies: { type: 'MessageResponse', isSingle: false },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_message_at: { type: 'DatetimeType', isSingle: true },
        read: { type: 'ReadStateResponse', isSingle: false },
        thread_participants: { type: 'ThreadParticipant', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        draft: { type: 'DraftResponse', isSingle: true },
        parent_message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.TruncateChannelResponse = (input) => {
    const typeMappings = {
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsBatchResponse = (input) => {
    const typeMappings = {
        counts_by_user: { type: 'UnreadCountsResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsChannel = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'UnreadCountsChannel', isSingle: false },
        threads: { type: 'UnreadCountsThread', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UnreadCountsThread = (input) => {
    const typeMappings = {
        last_read: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateBlockListResponse = (input) => {
    const typeMappings = {
        blocklist: { type: 'BlockListResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallMembersResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallResponse = (input) => {
    const typeMappings = {
        members: { type: 'MemberResponse', isSingle: false },
        call: { type: 'CallResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCallTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelPartialResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMemberResponse', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelResponse = (input) => {
    const typeMappings = {
        members: { type: 'ChannelMember', isSingle: false },
        channel: { type: 'ChannelResponse', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateChannelTypeResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateCommandResponse = (input) => {
    const typeMappings = {
        command: { type: 'Command', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMemberPartialResponse = (input) => {
    const typeMappings = {
        channel_member: { type: 'ChannelMemberResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMessagePartialResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateMessageResponse = (input) => {
    const typeMappings = {
        message: { type: 'MessageResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateThreadPartialResponse = (input) => {
    const typeMappings = {
        thread: { type: 'ThreadResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpdateUsersResponse = (input) => {
    const typeMappings = {
        users: { type: 'FullUserResponse', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpsertConfigResponse = (input) => {
    const typeMappings = {
        config: { type: 'ConfigResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertModerationTemplateResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UpsertPushPreferencesResponse = (input) => {
    const typeMappings = {
        user_preferences: { type: 'PushPreferences', isSingle: false },
    };
    return decode(typeMappings, input);
};
decoders.UpsertPushProviderResponse = (input) => {
    const typeMappings = {
        push_provider: { type: 'PushProviderResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.User = (input) => {
    const typeMappings = {
        ban_expires: { type: 'DatetimeType', isSingle: true },
        created_at: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        last_engaged_at: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMute = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        target: { type: 'User', isSingle: true },
        user: { type: 'User', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserMuteResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        expires: { type: 'DatetimeType', isSingle: true },
        target: { type: 'UserResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.UserResponse = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        ban_expires: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
        devices: { type: 'DeviceResponse', isSingle: false },
        push_notifications: {
            type: 'PushNotificationSettingsResponse',
            isSingle: true,
        },
    };
    return decode(typeMappings, input);
};
decoders.UserResponseCommonFields = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        updated_at: { type: 'DatetimeType', isSingle: true },
        deactivated_at: { type: 'DatetimeType', isSingle: true },
        deleted_at: { type: 'DatetimeType', isSingle: true },
        last_active: { type: 'DatetimeType', isSingle: true },
        revoke_tokens_issued_before: { type: 'DatetimeType', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.WSEvent = (input) => {
    const typeMappings = {
        created_at: { type: 'DatetimeType', isSingle: true },
        channel_last_message_at: { type: 'DatetimeType', isSingle: true },
        channel: { type: 'ChannelResponse', isSingle: true },
        created_by: { type: 'UserResponse', isSingle: true },
        me: { type: 'OwnUserResponse', isSingle: true },
        member: { type: 'ChannelMember', isSingle: true },
        message: { type: 'MessageResponse', isSingle: true },
        poll: { type: 'PollResponseData', isSingle: true },
        poll_vote: { type: 'PollVoteResponseData', isSingle: true },
        reaction: { type: 'ReactionResponse', isSingle: true },
        thread: { type: 'ThreadResponse', isSingle: true },
        user: { type: 'UserResponse', isSingle: true },
    };
    return decode(typeMappings, input);
};
decoders.WrappedUnreadCountsResponse = (input) => {
    const typeMappings = {
        channels: { type: 'UnreadCountsChannel', isSingle: false },
        threads: { type: 'UnreadCountsThread', isSingle: false },
    };
    return decode(typeMappings, input);
};

class CommonApi extends BaseApi {
    constructor() {
        super(...arguments);
        this.getApp = async () => {
            const response = await this.sendRequest('GET', '/api/v2/app', undefined, undefined);
            decoders.GetApplicationResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateApp = async (request) => {
            const body = {
                async_url_enrich_enabled: request?.async_url_enrich_enabled,
                auto_translation_enabled: request?.auto_translation_enabled,
                before_message_send_hook_url: request?.before_message_send_hook_url,
                cdn_expiration_seconds: request?.cdn_expiration_seconds,
                channel_hide_members_only: request?.channel_hide_members_only,
                custom_action_handler_url: request?.custom_action_handler_url,
                disable_auth_checks: request?.disable_auth_checks,
                disable_permissions_checks: request?.disable_permissions_checks,
                enforce_unique_usernames: request?.enforce_unique_usernames,
                feeds_moderation_enabled: request?.feeds_moderation_enabled,
                feeds_v2_region: request?.feeds_v2_region,
                guest_user_creation_disabled: request?.guest_user_creation_disabled,
                image_moderation_enabled: request?.image_moderation_enabled,
                migrate_permissions_to_v2: request?.migrate_permissions_to_v2,
                moderation_enabled: request?.moderation_enabled,
                moderation_webhook_url: request?.moderation_webhook_url,
                multi_tenant_enabled: request?.multi_tenant_enabled,
                permission_version: request?.permission_version,
                reminders_interval: request?.reminders_interval,
                reminders_max_members: request?.reminders_max_members,
                revoke_tokens_issued_before: request?.revoke_tokens_issued_before,
                sns_key: request?.sns_key,
                sns_secret: request?.sns_secret,
                sns_topic_arn: request?.sns_topic_arn,
                sqs_key: request?.sqs_key,
                sqs_secret: request?.sqs_secret,
                sqs_url: request?.sqs_url,
                webhook_url: request?.webhook_url,
                allowed_flag_reasons: request?.allowed_flag_reasons,
                image_moderation_block_labels: request?.image_moderation_block_labels,
                image_moderation_labels: request?.image_moderation_labels,
                user_search_disallowed_roles: request?.user_search_disallowed_roles,
                webhook_events: request?.webhook_events,
                apn_config: request?.apn_config,
                async_moderation_config: request?.async_moderation_config,
                datadog_info: request?.datadog_info,
                file_upload_config: request?.file_upload_config,
                firebase_config: request?.firebase_config,
                grants: request?.grants,
                huawei_config: request?.huawei_config,
                image_upload_config: request?.image_upload_config,
                push_config: request?.push_config,
                xiaomi_config: request?.xiaomi_config,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/app', undefined, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listBlockLists = async (request) => {
            const queryParams = {
                team: request?.team,
            };
            const response = await this.sendRequest('GET', '/api/v2/blocklists', undefined, queryParams);
            decoders.ListBlockListResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createBlockList = async (request) => {
            const body = {
                name: request?.name,
                words: request?.words,
                team: request?.team,
                type: request?.type,
            };
            const response = await this.sendRequest('POST', '/api/v2/blocklists', undefined, undefined, body);
            decoders.CreateBlockListResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteBlockList = async (request) => {
            const queryParams = {
                team: request?.team,
            };
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/blocklists/{name}', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getBlockList = async (request) => {
            const queryParams = {
                team: request?.team,
            };
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('GET', '/api/v2/blocklists/{name}', pathParams, queryParams);
            decoders.GetBlockListResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateBlockList = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const body = {
                team: request?.team,
                words: request?.words,
            };
            const response = await this.sendRequest('PUT', '/api/v2/blocklists/{name}', pathParams, undefined, body);
            decoders.UpdateBlockListResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.checkPush = async (request) => {
            const body = {
                apn_template: request?.apn_template,
                firebase_data_template: request?.firebase_data_template,
                firebase_template: request?.firebase_template,
                message_id: request?.message_id,
                push_provider_name: request?.push_provider_name,
                push_provider_type: request?.push_provider_type,
                skip_devices: request?.skip_devices,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/check_push', undefined, undefined, body);
            decoders.CheckPushResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.checkSNS = async (request) => {
            const body = {
                sns_key: request?.sns_key,
                sns_secret: request?.sns_secret,
                sns_topic_arn: request?.sns_topic_arn,
            };
            const response = await this.sendRequest('POST', '/api/v2/check_sns', undefined, undefined, body);
            decoders.CheckSNSResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.checkSQS = async (request) => {
            const body = {
                sqs_key: request?.sqs_key,
                sqs_secret: request?.sqs_secret,
                sqs_url: request?.sqs_url,
            };
            const response = await this.sendRequest('POST', '/api/v2/check_sqs', undefined, undefined, body);
            decoders.CheckSQSResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteDevice = async (request) => {
            const queryParams = {
                id: request?.id,
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/devices', undefined, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listDevices = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/devices', undefined, queryParams);
            decoders.ListDevicesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createDevice = async (request) => {
            const body = {
                id: request?.id,
                push_provider: request?.push_provider,
                push_provider_name: request?.push_provider_name,
                user_id: request?.user_id,
                voip_token: request?.voip_token,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/devices', undefined, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.exportUsers = async (request) => {
            const body = {
                user_ids: request?.user_ids,
            };
            const response = await this.sendRequest('POST', '/api/v2/export/users', undefined, undefined, body);
            decoders.ExportUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listExternalStorage = async () => {
            const response = await this.sendRequest('GET', '/api/v2/external_storage', undefined, undefined);
            decoders.ListExternalStorageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createExternalStorage = async (request) => {
            const body = {
                bucket: request?.bucket,
                name: request?.name,
                storage_type: request?.storage_type,
                gcs_credentials: request?.gcs_credentials,
                path: request?.path,
                aws_s3: request?.aws_s3,
                azure_blob: request?.azure_blob,
            };
            const response = await this.sendRequest('POST', '/api/v2/external_storage', undefined, undefined, body);
            decoders.CreateExternalStorageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteExternalStorage = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/external_storage/{name}', pathParams, undefined);
            decoders.DeleteExternalStorageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateExternalStorage = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const body = {
                bucket: request?.bucket,
                storage_type: request?.storage_type,
                gcs_credentials: request?.gcs_credentials,
                path: request?.path,
                aws_s3: request?.aws_s3,
                azure_blob: request?.azure_blob,
            };
            const response = await this.sendRequest('PUT', '/api/v2/external_storage/{name}', pathParams, undefined, body);
            decoders.UpdateExternalStorageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.checkExternalStorage = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('GET', '/api/v2/external_storage/{name}/check', pathParams, undefined);
            decoders.CheckExternalStorageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createGuest = async (request) => {
            const body = {
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/guest', undefined, undefined, body);
            decoders.CreateGuestResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createImportURL = async (request) => {
            const body = {
                filename: request?.filename,
            };
            const response = await this.sendRequest('POST', '/api/v2/import_urls', undefined, undefined, body);
            decoders.CreateImportURLResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listImports = async () => {
            const response = await this.sendRequest('GET', '/api/v2/imports', undefined, undefined);
            decoders.ListImportsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createImport = async (request) => {
            const body = {
                mode: request?.mode,
                path: request?.path,
            };
            const response = await this.sendRequest('POST', '/api/v2/imports', undefined, undefined, body);
            decoders.CreateImportResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getImport = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/imports/{id}', pathParams, undefined);
            decoders.GetImportResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getOG = async (request) => {
            const queryParams = {
                url: request?.url,
            };
            const response = await this.sendRequest('GET', '/api/v2/og', undefined, queryParams);
            decoders.GetOGResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listPermissions = async () => {
            const response = await this.sendRequest('GET', '/api/v2/permissions', undefined, undefined);
            decoders.ListPermissionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getPermission = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/permissions/{id}', pathParams, undefined);
            decoders.GetCustomPermissionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listPushProviders = async () => {
            const response = await this.sendRequest('GET', '/api/v2/push_providers', undefined, undefined);
            decoders.ListPushProvidersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.upsertPushProvider = async (request) => {
            const body = {
                push_provider: request?.push_provider,
            };
            const response = await this.sendRequest('POST', '/api/v2/push_providers', undefined, undefined, body);
            decoders.UpsertPushProviderResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deletePushProvider = async (request) => {
            const pathParams = {
                type: request?.type,
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/push_providers/{type}/{name}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getRateLimits = async (request) => {
            const queryParams = {
                server_side: request?.server_side,
                android: request?.android,
                ios: request?.ios,
                web: request?.web,
                endpoints: request?.endpoints,
            };
            const response = await this.sendRequest('GET', '/api/v2/rate_limits', undefined, queryParams);
            decoders.GetRateLimitsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listRoles = async () => {
            const response = await this.sendRequest('GET', '/api/v2/roles', undefined, undefined);
            decoders.ListRolesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createRole = async (request) => {
            const body = {
                name: request?.name,
            };
            const response = await this.sendRequest('POST', '/api/v2/roles', undefined, undefined, body);
            decoders.CreateRoleResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteRole = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/roles/{name}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getTask = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/tasks/{id}', pathParams, undefined);
            decoders.GetTaskResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryUsers = async (request) => {
            const queryParams = {
                payload: request?.payload,
            };
            const response = await this.sendRequest('GET', '/api/v2/users', undefined, queryParams);
            decoders.QueryUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateUsersPartial = async (request) => {
            const body = {
                users: request?.users,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/users', undefined, undefined, body);
            decoders.UpdateUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateUsers = async (request) => {
            const body = {
                users: request?.users,
            };
            const response = await this.sendRequest('POST', '/api/v2/users', undefined, undefined, body);
            decoders.UpdateUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getBlockedUsers = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/users/block', undefined, queryParams);
            decoders.GetBlockedUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.blockUsers = async (request) => {
            const body = {
                blocked_user_id: request?.blocked_user_id,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/block', undefined, undefined, body);
            decoders.BlockUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deactivateUsers = async (request) => {
            const body = {
                user_ids: request?.user_ids,
                created_by_id: request?.created_by_id,
                mark_channels_deleted: request?.mark_channels_deleted,
                mark_messages_deleted: request?.mark_messages_deleted,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/deactivate', undefined, undefined, body);
            decoders.DeactivateUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteUsers = async (request) => {
            const body = {
                user_ids: request?.user_ids,
                calls: request?.calls,
                conversations: request?.conversations,
                messages: request?.messages,
                new_call_owner_id: request?.new_call_owner_id,
                new_channel_owner_id: request?.new_channel_owner_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/delete', undefined, undefined, body);
            decoders.DeleteUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.reactivateUsers = async (request) => {
            const body = {
                user_ids: request?.user_ids,
                created_by_id: request?.created_by_id,
                restore_channels: request?.restore_channels,
                restore_messages: request?.restore_messages,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/reactivate', undefined, undefined, body);
            decoders.ReactivateUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.restoreUsers = async (request) => {
            const body = {
                user_ids: request?.user_ids,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/restore', undefined, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unblockUsers = async (request) => {
            const body = {
                blocked_user_id: request?.blocked_user_id,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/unblock', undefined, undefined, body);
            decoders.UnblockUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deactivateUser = async (request) => {
            const pathParams = {
                user_id: request?.user_id,
            };
            const body = {
                created_by_id: request?.created_by_id,
                mark_messages_deleted: request?.mark_messages_deleted,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/{user_id}/deactivate', pathParams, undefined, body);
            decoders.DeactivateUserResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.exportUser = async (request) => {
            const pathParams = {
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/users/{user_id}/export', pathParams, undefined);
            decoders.ExportUserResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.reactivateUser = async (request) => {
            const pathParams = {
                user_id: request?.user_id,
            };
            const body = {
                created_by_id: request?.created_by_id,
                name: request?.name,
                restore_messages: request?.restore_messages,
            };
            const response = await this.sendRequest('POST', '/api/v2/users/{user_id}/reactivate', pathParams, undefined, body);
            decoders.ReactivateUserResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
    }
}

class VideoApi extends BaseApi {
    constructor() {
        super(...arguments);
        this.queryUserFeedback = async (request) => {
            const queryParams = {
                full: request?.full,
            };
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter_conditions: request?.filter_conditions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/feedback', undefined, queryParams, body);
            decoders.QueryUserFeedbackResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryCallMembers = async (request) => {
            const body = {
                id: request?.id,
                type: request?.type,
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter_conditions: request?.filter_conditions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/members', undefined, undefined, body);
            decoders.QueryCallMembersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryCallStats = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter_conditions: request?.filter_conditions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/stats', undefined, undefined, body);
            decoders.QueryCallStatsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getCall = async (request) => {
            const queryParams = {
                members_limit: request?.members_limit,
                ring: request?.ring,
                notify: request?.notify,
                video: request?.video,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/video/call/{type}/{id}', pathParams, queryParams);
            decoders.GetCallResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateCall = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                starts_at: request?.starts_at,
                custom: request?.custom,
                settings_override: request?.settings_override,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/video/call/{type}/{id}', pathParams, undefined, body);
            decoders.UpdateCallResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getOrCreateCall = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                members_limit: request?.members_limit,
                notify: request?.notify,
                ring: request?.ring,
                video: request?.video,
                data: request?.data,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}', pathParams, undefined, body);
            decoders.GetOrCreateCallResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.blockUser = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/block', pathParams, undefined, body);
            decoders.BlockUserResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteCall = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                hard: request?.hard,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/delete', pathParams, undefined, body);
            decoders.DeleteCallResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.sendCallEvent = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
                custom: request?.custom,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/event', pathParams, undefined, body);
            decoders.SendCallEventResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.collectUserFeedback = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                rating: request?.rating,
                sdk: request?.sdk,
                sdk_version: request?.sdk_version,
                reason: request?.reason,
                user_session_id: request?.user_session_id,
                custom: request?.custom,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/feedback', pathParams, undefined, body);
            decoders.CollectUserFeedbackResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.goLive = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                recording_storage_name: request?.recording_storage_name,
                start_closed_caption: request?.start_closed_caption,
                start_hls: request?.start_hls,
                start_recording: request?.start_recording,
                start_transcription: request?.start_transcription,
                transcription_storage_name: request?.transcription_storage_name,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/go_live', pathParams, undefined, body);
            decoders.GoLiveResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.endCall = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/mark_ended', pathParams, undefined);
            decoders.EndCallResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateCallMembers = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                remove_members: request?.remove_members,
                update_members: request?.update_members,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/members', pathParams, undefined, body);
            decoders.UpdateCallMembersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.muteUsers = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                audio: request?.audio,
                mute_all_users: request?.mute_all_users,
                muted_by_id: request?.muted_by_id,
                screenshare: request?.screenshare,
                screenshare_audio: request?.screenshare_audio,
                video: request?.video,
                user_ids: request?.user_ids,
                muted_by: request?.muted_by,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/mute_users', pathParams, undefined, body);
            decoders.MuteUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryCallParticipants = async (request) => {
            const queryParams = {
                limit: request?.limit,
            };
            const pathParams = {
                id: request?.id,
                type: request?.type,
            };
            const body = {
                filter_conditions: request?.filter_conditions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/participants', pathParams, queryParams, body);
            decoders.QueryCallParticipantsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.videoPin = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                session_id: request?.session_id,
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/pin', pathParams, undefined, body);
            decoders.PinResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listRecordings = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/video/call/{type}/{id}/recordings', pathParams, undefined);
            decoders.ListRecordingsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getCallReport = async (request) => {
            const queryParams = {
                session_id: request?.session_id,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/video/call/{type}/{id}/report', pathParams, queryParams);
            decoders.GetCallReportResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startRTMPBroadcasts = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                broadcasts: request?.broadcasts,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts', pathParams, undefined, body);
            decoders.StartRTMPBroadcastsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopAllRTMPBroadcasts = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts/stop', pathParams, undefined);
            decoders.StopAllRTMPBroadcastsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopRTMPBroadcast = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
                name: request?.name,
            };
            const body = {};
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/rtmp_broadcasts/{name}/stop', pathParams, undefined, body);
            decoders.StopRTMPBroadcastsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startHLSBroadcasting = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_broadcasting', pathParams, undefined);
            decoders.StartHLSBroadcastingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startClosedCaptions = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                enable_transcription: request?.enable_transcription,
                external_storage: request?.external_storage,
                language: request?.language,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_closed_captions', pathParams, undefined, body);
            decoders.StartClosedCaptionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startFrameRecording = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                recording_external_storage: request?.recording_external_storage,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_frame_recording', pathParams, undefined, body);
            decoders.StartFrameRecordingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startRecording = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                recording_external_storage: request?.recording_external_storage,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_recording', pathParams, undefined, body);
            decoders.StartRecordingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startTranscription = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                enable_closed_captions: request?.enable_closed_captions,
                language: request?.language,
                transcription_external_storage: request?.transcription_external_storage,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/start_transcription', pathParams, undefined, body);
            decoders.StartTranscriptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopHLSBroadcasting = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_broadcasting', pathParams, undefined);
            decoders.StopHLSBroadcastingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopClosedCaptions = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                stop_transcription: request?.stop_transcription,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_closed_captions', pathParams, undefined, body);
            decoders.StopClosedCaptionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopFrameRecording = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_frame_recording', pathParams, undefined);
            decoders.StopFrameRecordingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopLive = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                continue_closed_caption: request?.continue_closed_caption,
                continue_hls: request?.continue_hls,
                continue_recording: request?.continue_recording,
                continue_rtmp_broadcasts: request?.continue_rtmp_broadcasts,
                continue_transcription: request?.continue_transcription,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_live', pathParams, undefined, body);
            decoders.StopLiveResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopRecording = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_recording', pathParams, undefined);
            decoders.StopRecordingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.stopTranscription = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                stop_closed_captions: request?.stop_closed_captions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/stop_transcription', pathParams, undefined, body);
            decoders.StopTranscriptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listTranscriptions = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/video/call/{type}/{id}/transcriptions', pathParams, undefined);
            decoders.ListTranscriptionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unblockUser = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/unblock', pathParams, undefined, body);
            decoders.UnblockUserResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.videoUnpin = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                session_id: request?.session_id,
                user_id: request?.user_id,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/unpin', pathParams, undefined, body);
            decoders.UnpinResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateUserPermissions = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
                grant_permissions: request?.grant_permissions,
                revoke_permissions: request?.revoke_permissions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/call/{type}/{id}/user_permissions', pathParams, undefined, body);
            decoders.UpdateUserPermissionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteRecording = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
                session: request?.session,
                filename: request?.filename,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/video/call/{type}/{id}/{session}/recordings/{filename}', pathParams, undefined);
            decoders.DeleteRecordingResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteTranscription = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
                session: request?.session,
                filename: request?.filename,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/video/call/{type}/{id}/{session}/transcriptions/{filename}', pathParams, undefined);
            decoders.DeleteTranscriptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryCalls = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter_conditions: request?.filter_conditions,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/calls', undefined, undefined, body);
            decoders.QueryCallsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listCallTypes = async () => {
            const response = await this.sendRequest('GET', '/api/v2/video/calltypes', undefined, undefined);
            decoders.ListCallTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createCallType = async (request) => {
            const body = {
                name: request?.name,
                external_storage: request?.external_storage,
                grants: request?.grants,
                notification_settings: request?.notification_settings,
                settings: request?.settings,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/calltypes', undefined, undefined, body);
            decoders.CreateCallTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteCallType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/video/calltypes/{name}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getCallType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('GET', '/api/v2/video/calltypes/{name}', pathParams, undefined);
            decoders.GetCallTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateCallType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const body = {
                external_storage: request?.external_storage,
                grants: request?.grants,
                notification_settings: request?.notification_settings,
                settings: request?.settings,
            };
            const response = await this.sendRequest('PUT', '/api/v2/video/calltypes/{name}', pathParams, undefined, body);
            decoders.UpdateCallTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getEdges = async () => {
            const response = await this.sendRequest('GET', '/api/v2/video/edges', undefined, undefined);
            decoders.GetEdgesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryAggregateCallStats = async (request) => {
            const body = {
                from: request?.from,
                to: request?.to,
                report_types: request?.report_types,
            };
            const response = await this.sendRequest('POST', '/api/v2/video/stats', undefined, undefined, body);
            decoders.QueryAggregateCallStatsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
    }
}

class CallApi {
    constructor(videoApi, type, id) {
        this.videoApi = videoApi;
        this.type = type;
        this.id = id;
        this.get = (request) => {
            return this.videoApi.getCall({ id: this.id, type: this.type, ...request });
        };
        this.update = (request) => {
            return this.videoApi.updateCall({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.getOrCreate = (request) => {
            return this.videoApi.getOrCreateCall({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.blockUser = (request) => {
            return this.videoApi.blockUser({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.delete = (request) => {
            return this.videoApi.deleteCall({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.sendCallEvent = (request) => {
            return this.videoApi.sendCallEvent({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.collectUserFeedback = (request) => {
            return this.videoApi.collectUserFeedback({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.goLive = (request) => {
            return this.videoApi.goLive({ id: this.id, type: this.type, ...request });
        };
        this.end = () => {
            return this.videoApi.endCall({ id: this.id, type: this.type });
        };
        this.updateCallMembers = (request) => {
            return this.videoApi.updateCallMembers({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.muteUsers = (request) => {
            return this.videoApi.muteUsers({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.queryCallParticipants = (request) => {
            return this.videoApi.queryCallParticipants({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.videoPin = (request) => {
            return this.videoApi.videoPin({ id: this.id, type: this.type, ...request });
        };
        this.listRecordings = () => {
            return this.videoApi.listRecordings({ id: this.id, type: this.type });
        };
        this.getCallReport = (request) => {
            return this.videoApi.getCallReport({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.startRTMPBroadcasts = (request) => {
            return this.videoApi.startRTMPBroadcasts({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.stopAllRTMPBroadcasts = () => {
            return this.videoApi.stopAllRTMPBroadcasts({
                id: this.id,
                type: this.type,
            });
        };
        this.stopRTMPBroadcast = (request) => {
            return this.videoApi.stopRTMPBroadcast({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.startHLSBroadcasting = () => {
            return this.videoApi.startHLSBroadcasting({ id: this.id, type: this.type });
        };
        this.startClosedCaptions = (request) => {
            return this.videoApi.startClosedCaptions({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.startFrameRecording = (request) => {
            return this.videoApi.startFrameRecording({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.startRecording = (request) => {
            return this.videoApi.startRecording({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.startTranscription = (request) => {
            return this.videoApi.startTranscription({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.stopHLSBroadcasting = () => {
            return this.videoApi.stopHLSBroadcasting({ id: this.id, type: this.type });
        };
        this.stopClosedCaptions = (request) => {
            return this.videoApi.stopClosedCaptions({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.stopFrameRecording = () => {
            return this.videoApi.stopFrameRecording({ id: this.id, type: this.type });
        };
        this.stopLive = (request) => {
            return this.videoApi.stopLive({ id: this.id, type: this.type, ...request });
        };
        this.stopRecording = () => {
            return this.videoApi.stopRecording({ id: this.id, type: this.type });
        };
        this.stopTranscription = (request) => {
            return this.videoApi.stopTranscription({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.listTranscriptions = () => {
            return this.videoApi.listTranscriptions({ id: this.id, type: this.type });
        };
        this.unblockUser = (request) => {
            return this.videoApi.unblockUser({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.videoUnpin = (request) => {
            return this.videoApi.videoUnpin({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.updateUserPermissions = (request) => {
            return this.videoApi.updateUserPermissions({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.deleteRecording = (request) => {
            return this.videoApi.deleteRecording({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.deleteTranscription = (request) => {
            return this.videoApi.deleteTranscription({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
    }
}

class StreamCall extends CallApi {
    constructor() {
        super(...arguments);
        this.create = this.getOrCreate;
        this.queryMembers = (request) => {
            return this.videoApi.queryCallMembers({
                id: this.id,
                type: this.type,
                ...(request ?? {}),
            });
        };
    }
    get cid() {
        return `${this.type}:${this.id}`;
    }
}

class StreamVideoClient extends VideoApi {
    constructor({ streamClient, ...apiConfig }) {
        super(apiConfig);
        this.call = (type, id) => {
            return new StreamCall(this, type, id);
        };
        this.connectOpenAi = async (options) => {
            let doCreateRealtimeClient;
            try {
                doCreateRealtimeClient = (await import('@stream-io/openai-realtime-api'))
                    .createRealtimeClient;
            }
            catch {
                throw new Error('Cannot create Realtime API client. Is @stream-io/openai-realtime-api installed?');
            }
            if (!options.agentUserId) {
                throw new Error('"agentUserId" must by specified in options');
            }
            const token = this.streamClient.generateCallToken({
                user_id: options.agentUserId,
                call_cids: [options.call.cid],
                validity_in_seconds: options.validityInSeconds,
            });
            const realtimeClient = doCreateRealtimeClient({
                baseUrl: this.apiConfig.baseUrl,
                call: options.call,
                streamApiKey: this.apiConfig.apiKey,
                streamUserToken: token,
                openAiApiKey: options.openAiApiKey,
                model: options.model,
            });
            await realtimeClient.connect();
            return realtimeClient;
        };
        this.streamClient = streamClient;
    }
}

class ChatApi extends BaseApi {
    constructor() {
        super(...arguments);
        this.queryCampaigns = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                user_limit: request?.user_limit,
                sort: request?.sort,
                filter: request?.filter,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/campaigns/query', undefined, undefined, body);
            decoders.QueryCampaignsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getCampaign = async (request) => {
            const queryParams = {
                prev: request?.prev,
                next: request?.next,
                limit: request?.limit,
            };
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/campaigns/{id}', pathParams, queryParams);
            decoders.GetCampaignResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.startCampaign = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                scheduled_for: request?.scheduled_for,
                stop_at: request?.stop_at,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/campaigns/{id}/start', pathParams, undefined, body);
            decoders.StartCampaignResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.scheduleCampaign = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {};
            const response = await this.sendRequest('POST', '/api/v2/chat/campaigns/{id}/stop', pathParams, undefined, body);
            decoders.CampaignResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryChannels = async (request) => {
            const body = {
                limit: request?.limit,
                member_limit: request?.member_limit,
                message_limit: request?.message_limit,
                offset: request?.offset,
                state: request?.state,
                user_id: request?.user_id,
                sort: request?.sort,
                filter_conditions: request?.filter_conditions,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels', undefined, undefined, body);
            decoders.QueryChannelsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteChannels = async (request) => {
            const body = {
                cids: request?.cids,
                hard_delete: request?.hard_delete,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/delete', undefined, undefined, body);
            decoders.DeleteChannelsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.markChannelsRead = async (request) => {
            const body = {
                user_id: request?.user_id,
                read_by_channel: request?.read_by_channel,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/read', undefined, undefined, body);
            decoders.MarkReadResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getOrCreateDistinctChannel = async (request) => {
            const pathParams = {
                type: request?.type,
            };
            const body = {
                hide_for_creator: request?.hide_for_creator,
                state: request?.state,
                thread_unread_counts: request?.thread_unread_counts,
                data: request?.data,
                members: request?.members,
                messages: request?.messages,
                watchers: request?.watchers,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/query', pathParams, undefined, body);
            decoders.ChannelStateResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteChannel = async (request) => {
            const queryParams = {
                hard_delete: request?.hard_delete,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}', pathParams, queryParams);
            decoders.DeleteChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateChannelPartial = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
                unset: request?.unset,
                set: request?.set,
                user: request?.user,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/chat/channels/{type}/{id}', pathParams, undefined, body);
            decoders.UpdateChannelPartialResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateChannel = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                accept_invite: request?.accept_invite,
                cooldown: request?.cooldown,
                hide_history: request?.hide_history,
                reject_invite: request?.reject_invite,
                skip_push: request?.skip_push,
                user_id: request?.user_id,
                add_members: request?.add_members,
                add_moderators: request?.add_moderators,
                assign_roles: request?.assign_roles,
                demote_moderators: request?.demote_moderators,
                invites: request?.invites,
                remove_members: request?.remove_members,
                data: request?.data,
                message: request?.message,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}', pathParams, undefined, body);
            decoders.UpdateChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteDraft = async (request) => {
            const queryParams = {
                parent_id: request?.parent_id,
                user_id: request?.user_id,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/draft', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getDraft = async (request) => {
            const queryParams = {
                parent_id: request?.parent_id,
                user_id: request?.user_id,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/channels/{type}/{id}/draft', pathParams, queryParams);
            decoders.GetDraftResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.sendEvent = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                event: request?.event,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/event', pathParams, undefined, body);
            decoders.EventResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteFile = async (request) => {
            const queryParams = {
                url: request?.url,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/file', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.uploadFile = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                file: request?.file,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/file', pathParams, undefined, body);
            decoders.FileUploadResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.hideChannel = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                clear_history: request?.clear_history,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/hide', pathParams, undefined, body);
            decoders.HideChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteImage = async (request) => {
            const queryParams = {
                url: request?.url,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/channels/{type}/{id}/image', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.uploadImage = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                file: request?.file,
                upload_sizes: request?.upload_sizes,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/image', pathParams, undefined, body);
            decoders.ImageUploadResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateMemberPartial = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                unset: request?.unset,
                set: request?.set,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/chat/channels/{type}/{id}/member', pathParams, queryParams, body);
            decoders.UpdateMemberPartialResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.sendMessage = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                message: request?.message,
                force_moderation: request?.force_moderation,
                keep_channel_hidden: request?.keep_channel_hidden,
                pending: request?.pending,
                skip_enrich_url: request?.skip_enrich_url,
                skip_push: request?.skip_push,
                pending_message_metadata: request?.pending_message_metadata,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/message', pathParams, undefined, body);
            decoders.SendMessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getManyMessages = async (request) => {
            const queryParams = {
                ids: request?.ids,
            };
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/channels/{type}/{id}/messages', pathParams, queryParams);
            decoders.GetManyMessagesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getOrCreateChannel = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                hide_for_creator: request?.hide_for_creator,
                state: request?.state,
                thread_unread_counts: request?.thread_unread_counts,
                data: request?.data,
                members: request?.members,
                messages: request?.messages,
                watchers: request?.watchers,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/query', pathParams, undefined, body);
            decoders.ChannelStateResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.markRead = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                message_id: request?.message_id,
                thread_id: request?.thread_id,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/read', pathParams, undefined, body);
            decoders.MarkReadResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.showChannel = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/show', pathParams, undefined, body);
            decoders.ShowChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.truncateChannel = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                hard_delete: request?.hard_delete,
                skip_push: request?.skip_push,
                truncated_at: request?.truncated_at,
                user_id: request?.user_id,
                message: request?.message,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/truncate', pathParams, undefined, body);
            decoders.TruncateChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.markUnread = async (request) => {
            const pathParams = {
                type: request?.type,
                id: request?.id,
            };
            const body = {
                message_id: request?.message_id,
                thread_id: request?.thread_id,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channels/{type}/{id}/unread', pathParams, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listChannelTypes = async () => {
            const response = await this.sendRequest('GET', '/api/v2/chat/channeltypes', undefined, undefined);
            decoders.ListChannelTypesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createChannelType = async (request) => {
            const body = {
                automod: request?.automod,
                automod_behavior: request?.automod_behavior,
                max_message_length: request?.max_message_length,
                name: request?.name,
                blocklist: request?.blocklist,
                blocklist_behavior: request?.blocklist_behavior,
                connect_events: request?.connect_events,
                custom_events: request?.custom_events,
                mark_messages_pending: request?.mark_messages_pending,
                message_retention: request?.message_retention,
                mutes: request?.mutes,
                partition_size: request?.partition_size,
                partition_ttl: request?.partition_ttl,
                polls: request?.polls,
                push_notifications: request?.push_notifications,
                reactions: request?.reactions,
                read_events: request?.read_events,
                replies: request?.replies,
                search: request?.search,
                skip_last_msg_update_for_system_msgs: request?.skip_last_msg_update_for_system_msgs,
                typing_events: request?.typing_events,
                uploads: request?.uploads,
                url_enrichment: request?.url_enrichment,
                blocklists: request?.blocklists,
                commands: request?.commands,
                permissions: request?.permissions,
                grants: request?.grants,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/channeltypes', undefined, undefined, body);
            decoders.CreateChannelTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteChannelType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/channeltypes/{name}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getChannelType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/channeltypes/{name}', pathParams, undefined);
            decoders.GetChannelTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateChannelType = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const body = {
                automod: request?.automod,
                automod_behavior: request?.automod_behavior,
                max_message_length: request?.max_message_length,
                blocklist: request?.blocklist,
                blocklist_behavior: request?.blocklist_behavior,
                connect_events: request?.connect_events,
                custom_events: request?.custom_events,
                mark_messages_pending: request?.mark_messages_pending,
                mutes: request?.mutes,
                partition_size: request?.partition_size,
                partition_ttl: request?.partition_ttl,
                polls: request?.polls,
                push_notifications: request?.push_notifications,
                quotes: request?.quotes,
                reactions: request?.reactions,
                read_events: request?.read_events,
                reminders: request?.reminders,
                replies: request?.replies,
                search: request?.search,
                skip_last_msg_update_for_system_msgs: request?.skip_last_msg_update_for_system_msgs,
                typing_events: request?.typing_events,
                uploads: request?.uploads,
                url_enrichment: request?.url_enrichment,
                allowed_flag_reasons: request?.allowed_flag_reasons,
                blocklists: request?.blocklists,
                commands: request?.commands,
                permissions: request?.permissions,
                automod_thresholds: request?.automod_thresholds,
                grants: request?.grants,
            };
            const response = await this.sendRequest('PUT', '/api/v2/chat/channeltypes/{name}', pathParams, undefined, body);
            decoders.UpdateChannelTypeResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.listCommands = async () => {
            const response = await this.sendRequest('GET', '/api/v2/chat/commands', undefined, undefined);
            decoders.ListCommandsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createCommand = async (request) => {
            const body = {
                description: request?.description,
                name: request?.name,
                args: request?.args,
                set: request?.set,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/commands', undefined, undefined, body);
            decoders.CreateCommandResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteCommand = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/commands/{name}', pathParams, undefined);
            decoders.DeleteCommandResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getCommand = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/commands/{name}', pathParams, undefined);
            decoders.GetCommandResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateCommand = async (request) => {
            const pathParams = {
                name: request?.name,
            };
            const body = {
                description: request?.description,
                args: request?.args,
                set: request?.set,
            };
            const response = await this.sendRequest('PUT', '/api/v2/chat/commands/{name}', pathParams, undefined, body);
            decoders.UpdateCommandResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryDrafts = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/drafts/query', undefined, undefined, body);
            decoders.QueryDraftsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.exportChannels = async (request) => {
            const body = {
                channels: request?.channels,
                clear_deleted_message_text: request?.clear_deleted_message_text,
                export_users: request?.export_users,
                include_soft_deleted_channels: request?.include_soft_deleted_channels,
                include_truncated_messages: request?.include_truncated_messages,
                version: request?.version,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/export_channels', undefined, undefined, body);
            decoders.ExportChannelsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryMembers = async (request) => {
            const queryParams = {
                payload: request?.payload,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/members', undefined, queryParams);
            decoders.MembersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryMessageHistory = async (request) => {
            const body = {
                filter: request?.filter,
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/history', undefined, undefined, body);
            decoders.QueryMessageHistoryResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteMessage = async (request) => {
            const queryParams = {
                hard: request?.hard,
                deleted_by: request?.deleted_by,
            };
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/messages/{id}', pathParams, queryParams);
            decoders.DeleteMessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getMessage = async (request) => {
            const queryParams = {
                show_deleted_message: request?.show_deleted_message,
            };
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/messages/{id}', pathParams, queryParams);
            decoders.GetMessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateMessage = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                message: request?.message,
                skip_enrich_url: request?.skip_enrich_url,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}', pathParams, undefined, body);
            decoders.UpdateMessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateMessagePartial = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                skip_enrich_url: request?.skip_enrich_url,
                user_id: request?.user_id,
                unset: request?.unset,
                set: request?.set,
                user: request?.user,
            };
            const response = await this.sendRequest('PUT', '/api/v2/chat/messages/{id}', pathParams, undefined, body);
            decoders.UpdateMessagePartialResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.runMessageAction = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                form_data: request?.form_data,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/action', pathParams, undefined, body);
            decoders.MessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.commitMessage = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {};
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/commit', pathParams, undefined, body);
            decoders.MessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.sendReaction = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                reaction: request?.reaction,
                enforce_unique: request?.enforce_unique,
                skip_push: request?.skip_push,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/reaction', pathParams, undefined, body);
            decoders.SendReactionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteReaction = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                id: request?.id,
                type: request?.type,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/messages/{id}/reaction/{type}', pathParams, queryParams);
            decoders.DeleteReactionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getReactions = async (request) => {
            const queryParams = {
                limit: request?.limit,
                offset: request?.offset,
            };
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/messages/{id}/reactions', pathParams, queryParams);
            decoders.GetReactionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryReactions = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/reactions', pathParams, undefined, body);
            decoders.QueryReactionsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.translateMessage = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                language: request?.language,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/translate', pathParams, undefined, body);
            decoders.MessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.undeleteMessage = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                message: request?.message,
                skip_enrich_url: request?.skip_enrich_url,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{id}/undelete', pathParams, undefined, body);
            decoders.UpdateMessageResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.castPollVote = async (request) => {
            const pathParams = {
                message_id: request?.message_id,
                poll_id: request?.poll_id,
            };
            const body = {
                user_id: request?.user_id,
                user: request?.user,
                vote: request?.vote,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/messages/{message_id}/polls/{poll_id}/vote', pathParams, undefined, body);
            decoders.PollVoteResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.removePollVote = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                message_id: request?.message_id,
                poll_id: request?.poll_id,
                vote_id: request?.vote_id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/messages/{message_id}/polls/{poll_id}/vote/{vote_id}', pathParams, queryParams);
            decoders.PollVoteResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getReplies = async (request) => {
            const queryParams = {
                limit: request?.limit,
                offset: request?.offset,
                id_gte: request?.id_gte,
                id_gt: request?.id_gt,
                id_lte: request?.id_lte,
                id_lt: request?.id_lt,
                created_at_after_or_equal: request?.created_at_after_or_equal,
                created_at_after: request?.created_at_after,
                created_at_before_or_equal: request?.created_at_before_or_equal,
                created_at_before: request?.created_at_before,
                id_around: request?.id_around,
                created_at_around: request?.created_at_around,
                sort: request?.sort,
            };
            const pathParams = {
                parent_id: request?.parent_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/messages/{parent_id}/replies', pathParams, queryParams);
            decoders.GetRepliesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryMessageFlags = async (request) => {
            const queryParams = {
                payload: request?.payload,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/moderation/flags/message', undefined, queryParams);
            decoders.QueryMessageFlagsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.muteChannel = async (request) => {
            const body = {
                expiration: request?.expiration,
                user_id: request?.user_id,
                channel_cids: request?.channel_cids,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/moderation/mute/channel', undefined, undefined, body);
            decoders.MuteChannelResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unmuteChannel = async (request) => {
            const body = {
                expiration: request?.expiration,
                user_id: request?.user_id,
                channel_cids: request?.channel_cids,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/moderation/unmute/channel', undefined, undefined, body);
            decoders.UnmuteResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createPoll = async (request) => {
            const body = {
                name: request?.name,
                allow_answers: request?.allow_answers,
                allow_user_suggested_options: request?.allow_user_suggested_options,
                description: request?.description,
                enforce_unique_vote: request?.enforce_unique_vote,
                id: request?.id,
                is_closed: request?.is_closed,
                max_votes_allowed: request?.max_votes_allowed,
                user_id: request?.user_id,
                voting_visibility: request?.voting_visibility,
                options: request?.options,
                custom: request?.custom,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/polls', undefined, undefined, body);
            decoders.PollResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updatePoll = async (request) => {
            const body = {
                id: request?.id,
                name: request?.name,
                allow_answers: request?.allow_answers,
                allow_user_suggested_options: request?.allow_user_suggested_options,
                description: request?.description,
                enforce_unique_vote: request?.enforce_unique_vote,
                is_closed: request?.is_closed,
                max_votes_allowed: request?.max_votes_allowed,
                user_id: request?.user_id,
                voting_visibility: request?.voting_visibility,
                options: request?.options,
                custom: request?.custom,
                user: request?.user,
            };
            const response = await this.sendRequest('PUT', '/api/v2/chat/polls', undefined, undefined, body);
            decoders.PollResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryPolls = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter: request?.filter,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/polls/query', undefined, queryParams, body);
            decoders.QueryPollsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deletePoll = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/polls/{poll_id}', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getPoll = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/polls/{poll_id}', pathParams, queryParams);
            decoders.PollResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updatePollPartial = async (request) => {
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const body = {
                user_id: request?.user_id,
                unset: request?.unset,
                set: request?.set,
                user: request?.user,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/chat/polls/{poll_id}', pathParams, undefined, body);
            decoders.PollResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.createPollOption = async (request) => {
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const body = {
                text: request?.text,
                position: request?.position,
                user_id: request?.user_id,
                custom: request?.custom,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/polls/{poll_id}/options', pathParams, undefined, body);
            decoders.PollOptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updatePollOption = async (request) => {
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const body = {
                id: request?.id,
                text: request?.text,
                user_id: request?.user_id,
                custom: request?.custom,
                user: request?.user,
            };
            const response = await this.sendRequest('PUT', '/api/v2/chat/polls/{poll_id}/options', pathParams, undefined, body);
            decoders.PollOptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deletePollOption = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                poll_id: request?.poll_id,
                option_id: request?.option_id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/polls/{poll_id}/options/{option_id}', pathParams, queryParams);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getPollOption = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                poll_id: request?.poll_id,
                option_id: request?.option_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/polls/{poll_id}/options/{option_id}', pathParams, queryParams);
            decoders.PollOptionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryPollVotes = async (request) => {
            const queryParams = {
                user_id: request?.user_id,
            };
            const pathParams = {
                poll_id: request?.poll_id,
            };
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter: request?.filter,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/polls/{poll_id}/votes', pathParams, queryParams, body);
            decoders.PollVotesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updatePushNotificationPreferences = async (request) => {
            const body = {
                preferences: request?.preferences,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/push_preferences', undefined, undefined, body);
            decoders.UpsertPushPreferencesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryBannedUsers = async (request) => {
            const queryParams = {
                payload: request?.payload,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/query_banned_users', undefined, queryParams);
            decoders.QueryBannedUsersResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.search = async (request) => {
            const queryParams = {
                payload: request?.payload,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/search', undefined, queryParams);
            decoders.SearchResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.querySegments = async (request) => {
            const body = {
                filter: request?.filter,
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/segments/query', undefined, undefined, body);
            decoders.QuerySegmentsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteSegment = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/chat/segments/{id}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getSegment = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/segments/{id}', pathParams, undefined);
            decoders.GetSegmentResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteSegmentTargets = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                target_ids: request?.target_ids,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/segments/{id}/deletetargets', pathParams, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.segmentTargetExists = async (request) => {
            const pathParams = {
                id: request?.id,
                target_id: request?.target_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/segments/{id}/target/{target_id}', pathParams, undefined);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.querySegmentTargets = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                sort: request?.sort,
                filter: request?.filter,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/segments/{id}/targets/query', pathParams, undefined, body);
            decoders.QuerySegmentTargetsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryThreads = async (request) => {
            const body = {
                limit: request?.limit,
                member_limit: request?.member_limit,
                next: request?.next,
                participant_limit: request?.participant_limit,
                prev: request?.prev,
                reply_limit: request?.reply_limit,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/threads', undefined, undefined, body);
            decoders.QueryThreadsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getThread = async (request) => {
            const queryParams = {
                reply_limit: request?.reply_limit,
                participant_limit: request?.participant_limit,
                member_limit: request?.member_limit,
            };
            const pathParams = {
                message_id: request?.message_id,
            };
            const response = await this.sendRequest('GET', '/api/v2/chat/threads/{message_id}', pathParams, queryParams);
            decoders.GetThreadResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.updateThreadPartial = async (request) => {
            const pathParams = {
                message_id: request?.message_id,
            };
            const body = {
                user_id: request?.user_id,
                unset: request?.unset,
                set: request?.set,
                user: request?.user,
            };
            const response = await this.sendRequest('PATCH', '/api/v2/chat/threads/{message_id}', pathParams, undefined, body);
            decoders.UpdateThreadPartialResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unreadCounts = async () => {
            const response = await this.sendRequest('GET', '/api/v2/chat/unread', undefined, undefined);
            decoders.WrappedUnreadCountsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unreadCountsBatch = async (request) => {
            const body = {
                user_ids: request?.user_ids,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/unread_batch', undefined, undefined, body);
            decoders.UnreadCountsBatchResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.sendUserCustomEvent = async (request) => {
            const pathParams = {
                user_id: request?.user_id,
            };
            const body = {
                event: request?.event,
            };
            const response = await this.sendRequest('POST', '/api/v2/chat/users/{user_id}/event', pathParams, undefined, body);
            decoders.Response?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
    }
}

class ChannelApi {
    constructor(chatApi, type, id) {
        this.chatApi = chatApi;
        this.type = type;
        this.id = id;
        this.delete = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.deleteChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.updateChannelPartial = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.updateChannelPartial({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.update = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.updateChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.deleteDraft = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.deleteDraft({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.getDraft = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.getDraft({ id: this.id, type: this.type, ...request });
        };
        this.sendEvent = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.sendEvent({ id: this.id, type: this.type, ...request });
        };
        this.deleteFile = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.deleteFile({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.uploadFile = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.uploadFile({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.hide = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.hideChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.deleteImage = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.deleteImage({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.uploadImage = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.uploadImage({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.updateMemberPartial = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.updateMemberPartial({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.sendMessage = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.sendMessage({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.getManyMessages = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.getManyMessages({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.getOrCreate = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.getOrCreateChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.markRead = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.markRead({ id: this.id, type: this.type, ...request });
        };
        this.show = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.showChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.truncate = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.truncateChannel({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
        this.markUnread = (request) => {
            if (!this.id) {
                throw new Error(`Channel isn't yet created, call getOrCreateDistinctChannel() before this operation`);
            }
            return this.chatApi.markUnread({
                id: this.id,
                type: this.type,
                ...request,
            });
        };
    }
}

class StreamChannel extends ChannelApi {
    constructor() {
        super(...arguments);
        this.getOrCreate = (channel_get_or_create_request) => {
            if (!this.id) {
                return this.chatApi
                    .getOrCreateDistinctChannel({
                    type: this.type,
                    ...channel_get_or_create_request,
                })
                    .then((response) => {
                    this.id = response.channel?.id;
                    return response;
                });
            }
            else {
                return this.chatApi.getOrCreateChannel({
                    id: this.id,
                    type: this.type,
                    ...channel_get_or_create_request,
                });
            }
        };
    }
    get cid() {
        return `${this.type}:${this.id}`;
    }
    queryMembers(request) {
        return this.chatApi.queryMembers({
            payload: {
                id: this.id,
                type: this.type,
                ...(request?.payload ?? { filter_conditions: {} }),
            },
        });
    }
}

class StreamChatClient extends ChatApi {
    constructor() {
        super(...arguments);
        this.channel = (type, id) => {
            return new StreamChannel(this, type, id);
        };
    }
}

class ModerationApi extends BaseApi {
    constructor() {
        super(...arguments);
        this.ban = async (request) => {
            const body = {
                target_user_id: request?.target_user_id,
                banned_by_id: request?.banned_by_id,
                channel_cid: request?.channel_cid,
                ip_ban: request?.ip_ban,
                reason: request?.reason,
                shadow: request?.shadow,
                timeout: request?.timeout,
                banned_by: request?.banned_by,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/ban', undefined, undefined, body);
            decoders.BanResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.check = async (request) => {
            const body = {
                config_key: request?.config_key,
                entity_creator_id: request?.entity_creator_id,
                entity_id: request?.entity_id,
                entity_type: request?.entity_type,
                config_team: request?.config_team,
                test_mode: request?.test_mode,
                user_id: request?.user_id,
                moderation_payload: request?.moderation_payload,
                options: request?.options,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/check', undefined, undefined, body);
            decoders.CheckResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.upsertConfig = async (request) => {
            const body = {
                key: request?.key,
                async: request?.async,
                team: request?.team,
                user_id: request?.user_id,
                ai_image_config: request?.ai_image_config,
                ai_text_config: request?.ai_text_config,
                ai_video_config: request?.ai_video_config,
                automod_platform_circumvention_config: request?.automod_platform_circumvention_config,
                automod_semantic_filters_config: request?.automod_semantic_filters_config,
                automod_toxicity_config: request?.automod_toxicity_config,
                aws_rekognition_config: request?.aws_rekognition_config,
                block_list_config: request?.block_list_config,
                bodyguard_config: request?.bodyguard_config,
                google_vision_config: request?.google_vision_config,
                rule_builder_config: request?.rule_builder_config,
                user: request?.user,
                velocity_filter_config: request?.velocity_filter_config,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/config', undefined, undefined, body);
            decoders.UpsertConfigResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.deleteConfig = async (request) => {
            const queryParams = {
                team: request?.team,
            };
            const pathParams = {
                key: request?.key,
            };
            const response = await this.sendRequest('DELETE', '/api/v2/moderation/config/{key}', pathParams, queryParams);
            decoders.DeleteModerationConfigResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getConfig = async (request) => {
            const queryParams = {
                team: request?.team,
            };
            const pathParams = {
                key: request?.key,
            };
            const response = await this.sendRequest('GET', '/api/v2/moderation/config/{key}', pathParams, queryParams);
            decoders.GetConfigResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryModerationConfigs = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/configs', undefined, undefined, body);
            decoders.QueryModerationConfigsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.customCheck = async (request) => {
            const body = {
                entity_id: request?.entity_id,
                entity_type: request?.entity_type,
                flags: request?.flags,
                entity_creator_id: request?.entity_creator_id,
                user_id: request?.user_id,
                moderation_payload: request?.moderation_payload,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/custom_check', undefined, undefined, body);
            decoders.CustomCheckResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.v2DeleteTemplate = async () => {
            const response = await this.sendRequest('DELETE', '/api/v2/moderation/feeds_moderation_template', undefined, undefined);
            decoders.DeleteModerationTemplateResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.v2QueryTemplates = async () => {
            const response = await this.sendRequest('GET', '/api/v2/moderation/feeds_moderation_template', undefined, undefined);
            decoders.QueryFeedModerationTemplatesResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.v2UpsertTemplate = async (request) => {
            const body = {
                name: request?.name,
                config: request?.config,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/feeds_moderation_template', undefined, undefined, body);
            decoders.UpsertModerationTemplateResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.flag = async (request) => {
            const body = {
                entity_id: request?.entity_id,
                entity_type: request?.entity_type,
                entity_creator_id: request?.entity_creator_id,
                reason: request?.reason,
                user_id: request?.user_id,
                custom: request?.custom,
                moderation_payload: request?.moderation_payload,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/flag', undefined, undefined, body);
            decoders.FlagResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryModerationLogs = async (request) => {
            const body = {
                limit: request?.limit,
                next: request?.next,
                prev: request?.prev,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/logs', undefined, undefined, body);
            decoders.QueryModerationLogsResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.mute = async (request) => {
            const body = {
                target_ids: request?.target_ids,
                timeout: request?.timeout,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/mute', undefined, undefined, body);
            decoders.MuteResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.queryReviewQueue = async (request) => {
            const body = {
                limit: request?.limit,
                lock_count: request?.lock_count,
                lock_duration: request?.lock_duration,
                lock_items: request?.lock_items,
                next: request?.next,
                prev: request?.prev,
                stats_only: request?.stats_only,
                user_id: request?.user_id,
                sort: request?.sort,
                filter: request?.filter,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/review_queue', undefined, undefined, body);
            decoders.QueryReviewQueueResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.getReviewQueueItem = async (request) => {
            const pathParams = {
                id: request?.id,
            };
            const response = await this.sendRequest('GET', '/api/v2/moderation/review_queue/{id}', pathParams, undefined);
            decoders.GetReviewQueueItemResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.submitAction = async (request) => {
            const body = {
                action_type: request?.action_type,
                item_id: request?.item_id,
                user_id: request?.user_id,
                ban: request?.ban,
                custom: request?.custom,
                delete_activity: request?.delete_activity,
                delete_message: request?.delete_message,
                delete_reaction: request?.delete_reaction,
                delete_user: request?.delete_user,
                mark_reviewed: request?.mark_reviewed,
                unban: request?.unban,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/submit_action', undefined, undefined, body);
            decoders.SubmitActionResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unban = async (request) => {
            const queryParams = {
                target_user_id: request?.target_user_id,
                channel_cid: request?.channel_cid,
                created_by: request?.created_by,
            };
            const body = {
                unbanned_by_id: request?.unbanned_by_id,
                unbanned_by: request?.unbanned_by,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/unban', undefined, queryParams, body);
            decoders.UnbanResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
        this.unmute = async (request) => {
            const body = {
                target_ids: request?.target_ids,
                user_id: request?.user_id,
                user: request?.user,
            };
            const response = await this.sendRequest('POST', '/api/v2/moderation/unmute', undefined, undefined, body);
            decoders.UnmuteResponse?.(response.body);
            return { ...response.body, metadata: response.metadata };
        };
    }
}

class StreamModerationClient extends ModerationApi {
}

class StreamClient extends CommonApi {
    /**
     *
     * @param apiKey
     * @param secret
     * @param config config object
     */
    constructor(apiKey, secret, config) {
        const token = JWTServerToken(secret);
        const timeout = config?.timeout ?? StreamClient.DEFAULT_TIMEOUT;
        const chatBaseUrl = config?.basePath ?? 'https://chat.stream-io-api.com';
        const videoBaseUrl = config?.basePath ?? 'https://video.stream-io-api.com';
        super({
            apiKey,
            token,
            timeout,
            baseUrl: chatBaseUrl,
            agent: config?.agent,
        });
        this.apiKey = apiKey;
        this.secret = secret;
        this.config = config;
        this.options = {};
        this.upsertUsers = (users) => {
            const payload = {};
            users.forEach((u) => {
                payload[u.id] = u;
            });
            return this.updateUsers({ users: payload });
        };
        this.queryBannedUsers = (request) => {
            return this.chat.queryBannedUsers(request);
        };
        /**
         *
         * @param payload
         * - user_id - the id of the user the token is for
         * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
         * - exp - when the token expires, unix timestamp in seconds
         * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
         */
        this.generateUserToken = (payload) => {
            const defaultIat = Math.floor((Date.now() - 1000) / 1000);
            payload.iat = payload.iat ?? defaultIat;
            const validityInSeconds = payload.validity_in_seconds ?? 60 * 60;
            payload.exp = payload.exp ?? payload.iat + validityInSeconds;
            return JWTUserToken(this.secret, payload);
        };
        /**
         *
         * @param payload
         * - user_id - the id of the user the token is for
         * - validity_in_seconds - how many seconds is the token valid for (starting from issued at), by default it's 1 hour, dicarded if exp is provided
         * - exp - when the token expires, unix timestamp in seconds
         * - iat - issued at date of the token, unix timestamp in seconds, by default it's now
         */
        this.generateCallToken = (payload) => {
            return this.generateUserToken(payload);
        };
        /**
         *
         * @param userID
         * @param exp
         * @param iat deprecated, the default date will be set internally
         * @returns
         *
         * @deprecated use generateUserToken instead
         */
        this.createToken = (userID, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) => {
            const payload = {
                user_id: userID,
                exp,
                iat,
            };
            return JWTUserToken(this.secret, payload);
        };
        /**
         *
         * @param userID
         * @param call_cids
         * @param exp
         * @param iat this is deprecated, the current date will be set internally
         * @returns
         *
         * @deprecated use generateCallToken instead
         */
        this.createCallToken = (userIdOrObject, call_cids, exp = Math.round(Date.now() / 1000) + 60 * 60, iat = Math.floor((Date.now() - 1000) / 1000)) => {
            const payload = {
                exp,
                iat,
                call_cids,
                user_id: typeof userIdOrObject === 'string'
                    ? userIdOrObject
                    : userIdOrObject.user_id,
            };
            if (typeof userIdOrObject === 'object' && userIdOrObject.role) {
                payload.role = userIdOrObject.role;
            }
            return JWTUserToken(this.secret, payload);
        };
        this.verifyWebhook = (requestBody, xSignature) => {
            const key = Buffer.from(this.secret, 'utf8');
            const hash = crypto
                .createHmac('sha256', key)
                .update(requestBody)
                .digest('hex');
            try {
                return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(xSignature));
            }
            catch (err) {
                return false;
            }
        };
        this.video = new StreamVideoClient({
            streamClient: this,
            apiKey,
            token,
            timeout,
            baseUrl: videoBaseUrl,
            agent: config?.agent,
        });
        this.chat = new StreamChatClient({
            apiKey,
            token,
            timeout,
            baseUrl: chatBaseUrl,
            agent: config?.agent,
        });
        this.moderation = new StreamModerationClient({
            apiKey,
            token,
            timeout,
            baseUrl: chatBaseUrl,
            agent: config?.agent,
        });
    }
}
StreamClient.DEFAULT_TIMEOUT = 3000;

export { ChannelOwnCapability, OwnCapability, StreamCall, StreamChannel, StreamChatClient, StreamClient, StreamVideoClient };
//# sourceMappingURL=index.es.mjs.map
